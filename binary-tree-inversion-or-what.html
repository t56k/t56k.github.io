<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/pico.min.css">
    <title>t56k devlog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MVS9VFCDJV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-MVS9VFCDJV');
    </script>
  </head>
<body>
            <header class="container">
                
    <nav>
        <ul>
            <li><strong><a href="/">t56k devlog</a></strong></li>
        </ul>
        <ul>
            <li><a href="https://github.com/t56k" target="_blank">gh</a></li>
            <li><a href="https://stackoverflow.com/users/1153022/t56k" target="_blank">so</a></li>
            <li><a href="https://twitter.com/t56k_" target="_blank">tw</a></li>
        </ul>
    </nav>
    <mark>Development notes from whenever</mark>

            </header>
            <main class="container">
                <small>Fri, 20 May 2022 08:45:06 +1000</small>
                <h1>Binary tree inversion or what</h1>
<p>Curveball:</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, invert the tree, and return its root.</p>
</blockquote>
<p>I know we all remember the detail here, but as a refresher let’s remind ourselves of the nuances of binary trees by seeing what Stack Overflow <a href="https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees">has to say</a>. <a href="https://stackoverflow.com/a/2159506/1153022">This</a> answer is pretty illuminating. Likewise that the <a href="https://stackoverflow.com/a/31144242/1153022">organization of Morse code is a binary tree</a>. Anyway:</p>
<p><mark><strong>tl;dr</strong></mark></p>
<blockquote>
<p><code>0(log n)</code> searches</p>
</blockquote>
<p>Got it.</p>
<p>Given that the implementation supplied with the question looks like this:</p>
<pre><code>#[derive(Debug, PartialEq, Eq)]
    pub struct TreeNode {
    pub val: i32,
    pub left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
    pub right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,
}

impl TreeNode {
#[inline]
    pub fn new(val: i32) -&gt; Self {
        TreeNode {
        val,
        left: None,
        right: None
        }
    }
}
</code></pre>
<p>It is more or less apparent that the question wants us to swap the <code>left</code> and <code>right</code> subnodes for each node. Who am I to deny them!</p>
<h2>First pass</h2>
<pre><code>use std::rc::Rc;
use std::cell::RefCell;

impl Solution {
    pub fn invert_tree(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        match root {
            Some(node) =&gt; {
                let (l, r) =
                    (Self::invert_tree(node.borrow().right.clone()),
                     Self::invert_tree(node.borrow().left.clone()));

                let node = node.clone();
                node.borrow_mut().left = l;
                node.borrow_mut().right = r;
                Some(node)
            },
            None =&gt; None,
        }
    }
}
</code></pre>
<p>Another bunt.</p>
<pre><code>Success
Runtime: 2 ms, faster than 40% of Rust online submissions for Invert Binary Tree.
Memory Usage: 2 MB, less than 61% of Rust Invert Binary Tree.
</code></pre>
<h2>Optimizations</h2>
<p>While it’s not a great solution, I think most optimizations available will be language-specific and nothing algorithmic. Trading a <code>match</code> for <code>if let Some</code> might show some benefit.</p>
<pre><code>use std::rc::Rc;
use std::cell::RefCell;

impl Solution {
    pub fn invert_tree(root: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt; {
        if let Some(node) = root.clone() {
            let mut node = node.borrow_mut();

            let (l, r) = (
                Self::invert_tree(node.left.clone()),
                Self::invert_tree(node.right.clone())
            );

            node.left = r;
            node.right = l;
        }

        root
    }
}
</code></pre>
<pre><code>Success
Runtime: 0 ms, faster than 100% of Rust online submissions for Invert Binary Tree.
Memory Usage: 2.1 MB, less than 63% of Rust Invert Binary Tree.
</code></pre>
<p>Hey ya.</p>

            </main>
        </body>
    <footer class="container">
      <small>Built with <a href="https://github.com/t56k/ssrg" target="_blank">ssrg</a> in 2022 by <a href="https://twitter.com/t56k_" target="_blank">t56k</a></small>
    </footer>
</html>