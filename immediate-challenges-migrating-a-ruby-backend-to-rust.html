<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/pico.min.css">
    <title>t56k devlog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MVS9VFCDJV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-MVS9VFCDJV');
    </script>
  </head>
<body>
            <header class="container">
                
    <nav>
        <ul>
            <li><strong><a href="/">t56k devlog</a></strong></li>
        </ul>
        <ul>
            <li><a href="https://github.com/t56k/" target="_blank">gh</a></li>
            <li><a href="https://stackoverflow.com/users/1153022/t56k" target="_blank">so</a></li>
            <li><a href="https://twitter.com/t56k_/" target="_blank">tw</a></li>
        </ul>
    </nav>
    <mark>Development notes from whenever</mark>

            </header>
            <main class="container">
                <small>Wed, 11 May 2022 08:48:44 +1000</small>
                <h1>Immediate challenges migrating a Ruby backend to Rust</h1>
<p>In migrating a midsize (12,000 LOC incl. tests) Ruby backend to Rust, a couple of immediate
challenges present.</p>
<p>First, given that the aim of this migration is to eliminate data-level errors in non-local
environments, the removal of non-necessary database columns seemed as good a place as any to start.
That said, determining redundant database columns is easier said than done.</p>
<p>We can <code>rake db:structure:dump</code> the Ruby app to get the schema in SQL which helps a bit, given that
Diesel requires migrations in SQL. We could also reverse-engineer the existing database but
that would mean we can’t recreate the environment in a straightforward manner. Plus, it wouldn’t
shed the redundant columns anyway. So far I’m just grepping parts of <code>structure.sql</code> and
hand-selecting what is required and what isn’t.</p>
<pre><code>rg 'CREATE TABLE public.users' structure.sql -A 52
</code></pre>
<p>About as good as we’re going to get here.</p>
<p>Second, and speaking of structure, I don’t want ~3,000 lines of Ruby controller files should be
in one <code>api.rs</code>. I guess one model-controller combination per database table is tolerable.</p>
<h2>First efforts</h2>
<p>We’re sticking with Postgres, and we’ll need an ORM. Diesel appears to be the de facto standard so
let’s keep it simple. We’ll use Warp as the HTTP server since I’ve used it in a microservice
recently and it affords a decent amount of flexibility without too much macro magic or anything of
the sort.</p>

            </main>
        </body>
    <footer class="container">
      <small>Built with <a href="https://github.com/t56k/ssrg" target="_blank">ssrg</a> in 2022 by <a href="https://twitter.com/t56k_" target="_blank">t56k</a></small>
    </footer>
</html>