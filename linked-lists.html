<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/pico.min.css">
    <title>t56k devlog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MVS9VFCDJV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-MVS9VFCDJV');
    </script>
  </head>
<body>
            <header class="container">
                
    <nav>
        <ul>
            <li><strong><a href="/">t56k devlog</a></strong></li>
        </ul>
        <ul>
            <li><a href="https://github.com/t56k/" target="_blank">gh</a></li>
            <li><a href="https://stackoverflow.com/users/1153022/t56k" target="_blank">so</a></li>
            <li><a href="https://twitter.com/t56k_/" target="_blank">tw</a></li>
        </ul>
    </nav>
    <mark>Development notes from whenever</mark>

            </header>
            <main class="container">
                <small>Wed, 18 May 2022 12:46:54 +1000</small>
                <h1>Linked lists</h1>
<p>Linked lists, huh? <em>Groan</em>. Officially, the problem is called “Merge two sorted lists” but whatever. Let’s get on with it.</p>
<blockquote>
<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.</p>
</blockquote>
<p>Example one:</p>
<pre><code>Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
</code></pre>
<h2>Sidebar</h2>
<p>I’ve never understood (or can’t remember) the point of this data structure, but since this Leetcode restart is about filling in gaps, let’s find out. A quick search on Stack Overflow reveals <a href="https://stackoverflow.com/questions/393556/when-to-use-a-linked-list-over-an-array-array-list">this</a> helpful thread (bookmarked!):</p>
<blockquote>
<p>Linked lists are preferable over arrays when:</p>
<ol>
<li>
<p>you need constant-time insertions/deletions from the list (such as in real-time computing where time predictability is absolutely critical)</p>
</li>
<li>
<p>you don’t know how many items will be in the list. With arrays, you may need to re-declare and copy memory if the array grows too big</p>
</li>
<li>
<p>you don’t need random access to any elements</p>
</li>
<li>
<p>you want to be able to insert items in the middle of the list (such as a priority queue)</p>
</li>
</ol>
<p>…</p>
<p>Linked lists are really cheap to add or remove items anywhere and to iterate, but random access is O(n).</p>
</blockquote>
<p>To wit:</p>
<pre><code>Algorithm           ArrayList   LinkedList
seek front            O(1)         O(1)
seek back             O(1)         O(1)
seek to index         O(1)         O(N)
insert at front       O(N)         O(1)
insert at back        O(1)         O(1)
insert after an item  O(N)         O(1)
</code></pre>
<p>Okay, fine, maybe they have some utility. This knowledge might help us solve the problem anyway.</p>
<h2>Splicing 101</h2>
<p>The problem gives us this definition for <code>ListNode</code>:</p>
<pre><code>#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
  pub val: i32,
  pub next: Option&lt;Box&lt;ListNode&gt;&gt;
}

impl ListNode {
  #[inline]
  fn new(val: i32) -&gt; Self {
    ListNode {
      next: None,
      val
    }
  }
}
</code></pre>
<p>Intuition tells us that to splice two lists together we need to iterate through the elements of the two lists and add them to a new resulting list, but not before comparing the elements to see which is greater.</p>
<pre><code>impl Solution {
    pub fn merge_two_lists(list1: Option&lt;Box&lt;ListNode&gt;&gt;, list2: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        // Allocate the result and make the two original lists mutable
        let mut head = ListNode::new(-1);
        let mut tail = &amp;mut head;
        let mut list1 = list1;
        let mut list2 = list2;

        // Nodes in both lists remaining (i.e., we have something to compare)
        while list1.is_some() &amp;&amp; list2.is_some() {
            if list1.as_ref().unwrap().val &lt;= list2.as_ref().unwrap().val {
                tail.next = list1.take();
                tail = tail.next.as_mut().unwrap();
                list1 = tail.next.take();
            } else {
                tail.next = list2.take();
                tail = tail.next.as_mut().unwrap();
                list2 = tail.next.take();
            }
        }

        // If the lists do not _both_ have remaining nodes
        if list1.is_some() {
            tail.next = list1.take();
        }

        if list2.is_some() {
            tail.next = list2.take();
        }

        head.next
    }
}
</code></pre>
<p>This approach works, and is low on memory, but it ain’t the fastest.</p>
<pre><code>Success
Runtime: 2 ms, faster than 54% of Rust online submissions for Merge Two Sorted Lists.
Memory Usage: 2 MB, less than 95% of Rust Merge Two Sorted Lists.
</code></pre>
<p>I have a hunch that if we can avoid the allocation at the start by <code>match</code>ing the lists we might be able to speed up the solution. That’s a fix for another day though.</p>

            </main>
        </body>
    <footer class="container">
      <small>Built with <a href="https://github.com/t56k/ssrg" target="_blank">ssrg</a> in 2022 by <a href="https://twitter.com/t56k_" target="_blank">t56k</a></small>
    </footer>
</html>