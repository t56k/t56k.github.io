<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/pico.min.css">
    <title>t56k devlog</title>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MVS9VFCDJV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-MVS9VFCDJV');
    </script>
  </head>
<body>
            <header class="container">
                
    <nav>
        <ul>
            <li><strong><a href="/">t56k devlog</a></strong></li>
        </ul>
        <ul>
            <li><a href="https://github.com/t56k" target="_blank">gh</a></li>
            <li><a href="https://stackoverflow.com/users/1153022/t56k" target="_blank">so</a></li>
            <li><a href="https://twitter.com/t56k_" target="_blank">tw</a></li>
        </ul>
    </nav>
    <mark>Development notes from whenever</mark>

            </header>
            <main class="container">
                <small>Tue, 24 May 2022 11:34:42 +1000</small>
                <h1>Something about maximum subarrays and dynamic programming</h1>
<p>Okay, back to basics.</p>
<blockquote>
<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
</blockquote>
<p>Sure. Let’s see what the first example says.</p>
<pre><code>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
</code></pre>
<p>Echoes of <a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane&#x27;s_algorithm">Kadane</a>.</p>
<h1>First pass</h1>
<p>It’s kinda straightforward enough. Loop through the <code>nums</code> <code>Vec</code> and check that each value is greater than zero. At that point we have two choices: either start again at the current index or add the current element to the previous sum.</p>
<pre><code>impl Solution {
    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut sub = vec![0; nums.len()]; // alloc subarray
        sub[0] = nums[0]; // assign init value for 1-len Vecs

        let mut res = sub[0]; // temp answer

        for i in 1..nums.len() {
            if sub[i - 1] &gt; 0 {
                sub[i] = sub[i - 1] + nums[i];
            } else {
                sub[i] = nums[i];
            }

            res = res.max(sub[i]);
        }

        res
    }
}
</code></pre>
<pre><code>Success
Runtime: 15 ms, faster than 61% of Rust online submissions for Maximum Subarray.
Memory Usage: 3.2 MB, less than 88% of Rust Maximum Subarray.
</code></pre>
<p>Pretty average as far as I’m concerned.</p>
<h2>Optimizations</h2>
<pre><code>impl Solution {
    pub fn max_sub_array(nums: Vec&lt;i32&gt;) -&gt; i32 {
        let mut tmp = 0i32;

        nums.iter().fold(nums[0], move |mut max, num| {
            tmp += num;
            max = max.max(tmp);
            tmp = tmp.max(0);

            max
        })
    }
}
</code></pre>
<pre><code>Success
Runtime: 10 ms, faster than 91% of Rust online submissions for Maximum Subarray.
Memory Usage: 3.4 MB, less than 19% of Rust Maximum Subarray.
</code></pre>
<p>The window for memory differences ain’t that big it seems.</p>

            </main>
        </body>
    <footer class="container">
      <small>Built with <a href="https://github.com/t56k/ssrg" target="_blank">ssrg</a> in 2022 by <a href="https://twitter.com/t56k_" target="_blank">t56k</a></small>
    </footer>
</html>